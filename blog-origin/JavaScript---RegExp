# RegExp类型

ECMAScript通过RegExp类型来支持正则表达式。
创建正则表达式：
```
var expression = / pattern / flags;
```
>其实的模式（pattern）部分可以是任何简单或者复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志。
> + g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
> + i：表示不区分大小写（case-insensitive）模式，即在确定匹配时忽略模式与字符串的大小写；
> + m：表示多行（multiline）模式，即在达到一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项；


因此一个正则表达式技师一个模式与上述3个标志的组合体。不同组合产生不同的结果，如下面的例子所示。
```
// 1、匹配字符串中所有的“at”的示例
var pattern1 = /at/g;

// 2、匹配第一个”bat”或者“cat”，不区分大小写
var pattern2 = /[bc]at/i;

// 3、匹配所有以“at”结尾的3个字符的组合，不区分大小写
var pattern3 = /.at/gi;
```
这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符就必须对他们进行转义。下面给出几个例子

```
// 1、匹配第一个“bat”或“cat”，不区分大小写
var pattern1 = /[bc]at/i;

// 2、匹配第一个“[bc]at”， 不区分大小写
var pattern2 = /\[bc\]at/i;

// 3、匹配所有以“at”结尾的3个字符的组合，不区分大小写
var pattern3 = /.at/gi;

// 4、匹配所有“.at”,不区分大小写
var pattern4 = /\.at/gi;
```
前面举得例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用RegExp构造函数，它接受两个参数：一个是要匹配的字符串，另一个是可选的标志字符串。可以使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示：
```
// 1、匹配第一个“bat”或“cat”，不区分大小写
var pattern1 = /[bc]at/i;

// 2、与pattern1相同，只不过是使用构造函数创建的
var pattern2 = new RegExp("[bc]at", i);
```

> 在此，pattern1和pattern2是两个完全等价的正则表达式。要注意的是，传递给RegExp构造函数的两个参数都是字符串（不能把正则表达式字面量传递给RegExp构造函数）。由于RegExp构造函数的模式参数是字符串，所有在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如：`\n`（字符`\`在字符串中通常被转义为`\\`，而在正则表达式字符串中就会转变成`\\\`)。下表给出了一些模式，左边是这些模式的字面量形式，右边是使用RegExp构造函数定义相同模式时使用的字符串。

<table>
  <tr>
    <td>字面量模式</td>
    <td>等价的字符串</td>
  </tr>
  <tr>
    <td>/\[bc\]at/</td>
    <td>"\\[bc\\]at"</td>
  </tr>
  <tr>
    <td>/\.at/</td>
    <td>"\\.at"</td>
  </tr>
  <tr>
    <td>/name\/age/</td>
    <td>"name\\/age"</td>
  </tr>
  <tr>
    <td>/\d.\d{1,2}/</td>
    <td>"\\d.\\d{1,2}"</td>
  </tr>
  <tr>
    <td>/\w\\hello\\123/</td>
    <td>"\\w\\\\hello\\\\123"</td>
  </tr>
</table>
> 使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样。在ECMAScript 3中，正则表达式字面量始终会共享一个RegExp示例，而使用构造函数创建的每一个新RegExp示例都是一个新实例。如：
> ```
> var re = null, i;
> for (i = 0; i < 10; i++) {
  re = /cat/g;
  re.test('catastrophe');
}
for (i = 0; i < 10; i++) {
  re = new RegExp("cat", "g");
  re.test("catastrophe");
}
> ```
> 在第一个循环中，技师是循环体中指定的，但实际上只为/cat/创建了一个RegExp实例。由于实例属性不会重叠，所以在循环中再次调用`test()`方法会失败。这是因为第一次调用`test()`找到`cat`，但第二次调用是从索引为3的字符（上一次匹配的末尾）开始的，所以就找不到它。由于会测试到字符串末尾，所以下一次在调用`test()`就又从头开始了。
> 第二个循环使用RegExp构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的RegExp实例，所以每次调用`test()`都会返回`true`。
> ECMAScript 5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp实例。

## 1、RegExp实例属性
RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息：
+ global：布尔值，表示是否设置了g属性
+ ignoreCase：布尔值，表示是否设置了i标志
+ lastIndex：整数，表示开始搜索下一个匹配的字符串位置，从0算起
+ multiline：布尔值，表示是否设置了m标志
+ source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。

通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全部包含在模式声明中，如：
```
var pattern1 = /\[bc\]at/i;

alert(pattern1.global);         // false
alert(pattern1.ignoreCase);     // true
alert(pattern1.multiline);      // false
alert(pattern1.lastIndex);      // 0
alert(pattern1.source);         // "\[bc\]at"

var pattern2 = new RegExp("\\[bc\\]at", "i");

alert(pattern2.global);         // false
alert(pattern2.ignoreCase);     // true
alert(pattern2.multiline);      // false
alert(pattern2.lastIndex);      // 0
alert(pattern2.source);         // "\[bc\]at"
```
## 2、RegExp 实例方法
RegExp对象主要方法是`exec()`，该方法是专门为捕获组而设计的。`exec()`接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项的数组；或者在没有匹配项的情况下返回`null`。返回的数组虽然是Array的实例，但包含两个额外的属性：`index`和`input`。其中，`index`表示匹配项在字符串中的位置，而`input`表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数据只包含一项）。
请看下面例子：
```
var text = "mom and dad and baby";
var pattern = /mom( and dad( and baby)?)?/gi;

var matches = pattern.exec(text);
alert(matches.index);         // 0
alert(matches.input);         // "mom and dad and baby"
alert(matches[0]);            // "mom and dad and baby"
alert(matches[1]);            // " and dad and baby"
alert(matches[2]);            // " and baby"
```
